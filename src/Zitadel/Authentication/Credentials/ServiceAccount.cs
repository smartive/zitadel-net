using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Jose;
using Microsoft.IdentityModel.Protocols;
using Microsoft.IdentityModel.Protocols.OpenIdConnect;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.OpenSsl;
using Org.BouncyCastle.Security;

#if NET5_0_OR_GREATER
using System.Net.Http.Json;
#endif

namespace Zitadel.Authentication.Credentials
{
    /// <summary>
    /// <para>
    /// A Zitadel <see cref="ServiceAccount"/> can be loaded from a json file
    /// and helps with authentication on a Zitadel IAM.
    /// </para>
    /// <para>
    /// The mechanism is defined here:
    /// <a href="https://docs.zitadel.ch/docs/apis/openidoauth/grant-types#json-web-token-jwt-profile">JSON Web Token (JWT) Profile</a>.
    /// <a href="https://docs.zitadel.ch/docs/guides/serviceusers#2-create-a-jwt-and-sign-with-private-key">Create a JWT and sigh it with the private key</a>.
    /// </para>
    /// </summary>
    public record ServiceAccount
    {
        private static readonly HttpClient HttpClient = new();

        /// <summary>
        /// The key type.
        /// </summary>
        public const string Type = "serviceaccount";

        /// <summary>
        /// The user id associated with this service account.
        /// </summary>
#if NET5_0_OR_GREATER
        public string UserId { get; init; } = string.Empty;
#elif NETCOREAPP3_1_OR_GREATER
        public string UserId { get; set; } = string.Empty;
#endif

        /// <summary>
        /// This is unique ID (on Zitadel) of the key.
        /// </summary>
#if NET5_0_OR_GREATER
        public string KeyId { get; init; } = string.Empty;
#elif NETCOREAPP3_1_OR_GREATER
        public string KeyId { get; set; } = string.Empty;
#endif

        /// <summary>
        /// The private key generated by Zitadel for this <see cref="ServiceAccount"/>.
        /// </summary>
#if NET5_0_OR_GREATER
        public string Key { get; init; } = string.Empty;
#elif NETCOREAPP3_1_OR_GREATER
        public string Key { get; set; } = string.Empty;
#endif

        /// <summary>
        /// Load a <see cref="ServiceAccount"/> from a file at a given (relative or absolute) path.
        /// </summary>
        /// <param name="pathToJson">The relative or absolute filepath to the json file.</param>
        /// <returns>The parsed <see cref="ServiceAccount"/>.</returns>
        /// <exception cref="FileNotFoundException">When the file does not exist.</exception>
        /// <exception cref="InvalidDataException">When the deserializer returns 'null'.</exception>
        /// <exception cref="System.Text.Json.JsonException">
        /// Thrown when the JSON is invalid,
        /// the <see cref="ServiceAccount"/> type is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        public static async Task<ServiceAccount> LoadFromJsonFileAsync(string pathToJson)
        {
            var path = Path.GetFullPath(
                Path.IsPathRooted(pathToJson)
                    ? pathToJson
                    : Path.Join(Directory.GetCurrentDirectory(), pathToJson));

            if (!File.Exists(path))
            {
                throw new FileNotFoundException($"File not found: {path}.", path);
            }

            await using var stream = File.OpenRead(path);
            return await LoadFromJsonStreamAsync(stream);
        }

        /// <inheritdoc cref="LoadFromJsonFileAsync"/>
        public static ServiceAccount LoadFromJsonFile(string pathToJson) => LoadFromJsonFileAsync(pathToJson).Result;

        /// <summary>
        /// Load a <see cref="ServiceAccount"/> from a given stream (FileStream, MemoryStream, ...).
        /// </summary>
        /// <param name="stream">The stream to read the json from.</param>
        /// <returns>The parsed <see cref="ServiceAccount"/>.</returns>
        /// <exception cref="InvalidDataException">When the deserializer returns 'null'.</exception>
        /// <exception cref="System.Text.Json.JsonException">
        /// Thrown when the JSON is invalid,
        /// the <see cref="ServiceAccount"/> type is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        public static async Task<ServiceAccount> LoadFromJsonStreamAsync(Stream stream) =>
            await JsonSerializer.DeserializeAsync<ServiceAccount>(
                stream,
                new() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }) ??
            throw new InvalidDataException("The json file yielded a 'null' result for deserialization.");

        /// <inheritdoc cref="LoadFromJsonStreamAsync"/>
        public static ServiceAccount LoadFromJsonStream(Stream stream) => LoadFromJsonStreamAsync(stream).Result;

        /// <summary>
        /// Load a <see cref="ServiceAccount"/> from a string that contains json.
        /// </summary>
        /// <param name="json">Json string.</param>
        /// <returns>The parsed <see cref="ServiceAccount"/>.</returns>
        /// <exception cref="InvalidDataException">When the deserializer returns 'null'.</exception>
        /// <exception cref="System.Text.Json.JsonException">
        /// Thrown when the JSON is invalid,
        /// the <see cref="ServiceAccount"/> type is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        public static async Task<ServiceAccount> LoadFromJsonStringAsync(string json)
        {
            await using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(json), 0, json.Length);
            return await LoadFromJsonStreamAsync(memoryStream);
        }

        /// <inheritdoc cref="LoadFromJsonStringAsync"/>
        public static ServiceAccount LoadFromJsonString(string json) => LoadFromJsonStringAsync(json).Result;

        /// <summary>
        /// Authenticate the given service account against the issuer in the options.
        /// As example, this token can be used to communicate with API applications or
        /// with the Zitadel API itself.
        /// </summary>
        /// <param name="authOptions"><see cref="AuthOptions"/> that contain the parameters for the authentication.</param>
        /// <returns>An opaque access token which can be used to communciate with relying parties.</returns>
        public async Task<string> AuthenticateAsync(AuthOptions authOptions)
        {
            var manager = new ConfigurationManager<OpenIdConnectConfiguration>(
                DiscoveryEndpoint(authOptions.DiscoveryEndpoint ?? authOptions.Endpoint),
                new OpenIdConnectConfigurationRetriever(),
                new HttpDocumentRetriever(HttpClient));

            var oidcConfig = await manager.GetConfigurationAsync();

            var jwt = await GetSignedJwtAsync(authOptions.Endpoint);
            var request = new HttpRequestMessage(HttpMethod.Post, oidcConfig.TokenEndpoint)
            {
                Content = new FormUrlEncodedContent(
                    new[]
                    {
                        new KeyValuePair<string?, string?>("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer"),
                        new KeyValuePair<string?, string?>(
                            "assertion",
                            $"{jwt}"),
                        new KeyValuePair<string?, string?>("scope", authOptions.CreateOidcScopes()),
                    }),
            };

            var response = await HttpClient.SendAsync(request);
#if NET5_0_OR_GREATER
            var token = await response
                .EnsureSuccessStatusCode()
                .Content
                .ReadFromJsonAsync<AccessTokenResponse>();
#elif NETCOREAPP3_1_OR_GREATER
            var content = await response
                .EnsureSuccessStatusCode()
                .Content
                .ReadAsStringAsync();
            var token = JsonSerializer.Deserialize<AccessTokenResponse>(content);
#endif

            return token?.AccessToken ?? throw new("Access token could not be parsed.");
        }

        /// <inheritdoc cref="AuthenticateAsync"/>
        public string Authenticate(AuthOptions authOptions) => AuthenticateAsync(authOptions).Result;

        private static string DiscoveryEndpoint(string discoveryEndpoint) =>
            discoveryEndpoint.EndsWith(ZitadelDefaults.DiscoveryEndpointPath)
                ? discoveryEndpoint
                : discoveryEndpoint.TrimEnd('/') + ZitadelDefaults.DiscoveryEndpointPath;

        private string GetSignedJwt(string issuer) => GetSignedJwtAsync(issuer).Result;

        private async Task<string> GetSignedJwtAsync(string issuer)
        {
            using var rsa = new RSACryptoServiceProvider();
            rsa.ImportParameters(await GetRsaParametersAsync());

            return JWT.Encode(
                new Dictionary<string, object>
                {
                    { "iss", UserId },
                    { "sub", UserId },
                    { "iat", DateTimeOffset.UtcNow.AddSeconds(-1).ToUnixTimeSeconds() },
                    { "exp", ((DateTimeOffset)DateTime.UtcNow.AddMinutes(1)).ToUnixTimeSeconds() },
                    { "aud", issuer },
                },
                rsa,
                JwsAlgorithm.RS256,
                new Dictionary<string, object>
                {
                    { "kid", KeyId },
                });
        }

        private async Task<RSAParameters> GetRsaParametersAsync()
        {
            var bytes = Encoding.UTF8.GetBytes(Key);
            await using var ms = new MemoryStream(bytes);
            using var sr = new StreamReader(ms);
            var pemReader = new PemReader(sr);

            if (!(pemReader.ReadObject() is AsymmetricCipherKeyPair keyPair))
            {
                throw new("RSA Keypair could not be read.");
            }

            return DotNetUtilities.ToRSAParameters(keyPair.Private as RsaPrivateCrtKeyParameters);
        }

        private record AccessTokenResponse
        {
            [JsonPropertyName("access_token")]
#if NET5_0_OR_GREATER
            public string AccessToken { get; init; } = string.Empty;
#elif NETCOREAPP3_1_OR_GREATER
            public string AccessToken { get; set; } = string.Empty;
#endif
        }

        /// <summary>
        /// Options for the authentication with a <see cref="ServiceAccount"/>.
        /// </summary>
        public record AuthOptions
        {
            /// <summary>
            /// Endpoint which will be called on the "token endpoint" to get an access token.
            /// Defaults to <see cref="ZitadelDefaults.Issuer"/>.
            /// </summary>
#if NET5_0_OR_GREATER
            public string Endpoint { get; init; } = ZitadelDefaults.Issuer;
#elif NETCOREAPP3_1_OR_GREATER
            public string Endpoint { get; set; } = ZitadelDefaults.Issuer;
#endif

            /// <summary>
            /// If set, overwrites the discovery endpoint for <see cref="Endpoint"/>.
            /// This may be used, if the discovery endpoint is not on the well-known url
            /// of the endpoint. Beware that the well-known part ("/.well-known/openid-configuration")
            /// is still attached to the url.
            /// </summary>
#if NET5_0_OR_GREATER
            public string? DiscoveryEndpoint { get; init; }
#elif NETCOREAPP3_1_OR_GREATER
            public string? DiscoveryEndpoint { get; set; }
#endif

            /// <summary>
            /// If set, the scope for a primary domain ("urn:zitadel:iam:org:domain:primary:{PrimaryDomain}")
            /// will be attached to the list of scopes for the access token of the service account.
            /// </summary>
#if NET5_0_OR_GREATER
            public string? PrimaryDomain { get; init; }
#elif NETCOREAPP3_1_OR_GREATER
            public string? PrimaryDomain { get; set; }
#endif

            /// <summary>
            /// Set a list of roles that must be attached to this service account to be
            /// successfully authenticated. Translates to the role scope ("urn:zitadel:iam:org:project:role:{Role}").
            /// </summary>
#if NET5_0_OR_GREATER
            public IList<string> RequiredRoles { get; init; } = new List<string>();
#elif NETCOREAPP3_1_OR_GREATER
            public IList<string> RequiredRoles { get; set; } = new List<string>();
#endif

            /// <summary>
            /// Set a list of audiences that are attached to the returned access token.
            /// Translates to the additional audience scope ("urn:zitadel:iam:org:project:id:{ProjectId}:aud").
            /// </summary>
#if NET5_0_OR_GREATER
            public IList<string> ProjectAudiences { get; init; } = new List<string>();
#elif NETCOREAPP3_1_OR_GREATER
            public IList<string> ProjectAudiences { get; set; } = new List<string>();
#endif

            /// <summary>
            /// List of arbitrary additional scopes that are concatenated into the scope.
            /// </summary>
#if NET5_0_OR_GREATER
            public IList<string> AdditionalScopes { get; init; } = new List<string>();
#elif NETCOREAPP3_1_OR_GREATER
            public IList<string> AdditionalScopes { get; set; } = new List<string>();
#endif

            internal string CreateOidcScopes() =>
                string.Join(
                    ' ',
                    new[]
                        {
                            "openid",
                            PrimaryDomain != null
                                ? $"urn:zitadel:iam:org:domain:primary:{PrimaryDomain}"
                                : string.Empty,
                        }
                        .Union(AdditionalScopes)
                        .Union(ProjectAudiences.Select(p => $"urn:zitadel:iam:org:project:id:{p}:aud"))
                        .Union(RequiredRoles.Select(r => $"urn:zitadel:iam:org:project:role:{r}"))
                        .Where(s => !string.IsNullOrWhiteSpace(s)));
        }
    }
}
